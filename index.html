<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>5D Tile Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6c757d;
            --dark-color: #343a40;
            --light-color: #f8f9fa;
        }
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        #app {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }
        #toolbar {
            width: 100%;
            background: var(--dark-color);
            display: flex;
            padding: 10px;
            overflow-x: auto;
            z-index: 100;
        }
        .tool-btn {
            width: 50px;
            height: 50px;
            margin: 0 5px;
            background: var(--secondary-color);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .tool-btn.active {
            background: var(--primary-color);
        }
        #sidebar {
            position: fixed;
            top: 70px;
            left: -300px;
            width: 250px;
            height: calc(100% - 70px);
            background: white;
            transition: transform 0.3s ease;
            z-index: 90;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        #sidebar.open {
            transform: translateX(300px);
        }
        #sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
        }
        #sidebar-content {
            padding: 15px;
        }
        #viewer-container {
            flex: 1;
            position: relative;
        }
        #viewer {
            width: 100%;
            height: 100%;
        }
        #mode-switcher {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            z-index: 10;
        }
        .mode-btn {
            padding: 8px 15px;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 500;
        }
        .mode-btn.active {
            background: var(--primary-color);
            color: white;
        }
        #stats-panel {
            position: fixed;
            top: 70px;
            right: -300px;
            width: 250px;
            height: calc(100% - 70px);
            background: rgba(255,255,255,0.95);
            transition: transform 0.3s ease;
            z-index: 90;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            padding: 15px;
            overflow-y: auto;
        }
        #stats-panel.open {
            transform: translateX(-300px);
        }
        .stat-item {
            margin-bottom: 8px;
        }
        .stat-label {
            font-size: 12px;
            color: var(--secondary-color);
        }
        .stat-value {
            font-weight: bold;
        }
        .material-thumb {
            width: 100%;
            height: 80px;
            background-size: cover;
            background-position: center;
            margin-bottom: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
        }
        .material-thumb.selected {
            border-color: var(--primary-color);
        }
        .material-item {
            margin-bottom: 15px;
        }
        .material-name {
            font-size: 14px;
            margin-bottom: 5px;
        }
        .section-title {
            font-weight: bold;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        #first-person-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
            display: none;
            z-index: 10;
        }
        #room-dimensions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }
        .dimension-input {
            margin-bottom: 10px;
        }
        .dimension-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 3px;
        }
        .dimension-input input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        #tile-size-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }
        #scan-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            display: none;
        }
        #scan-view {
            width: 90%;
            height: 60%;
            background: #000;
            margin-bottom: 20px;
            position: relative;
        }
        #scan-controls {
            display: flex;
            flex-direction: column;
            width: 90%;
        }
        #scan-button {
            padding: 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        #cancel-scan {
            padding: 12px;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
        }
        #scan-results {
            color: white;
            margin-top: 20px;
            text-align: center;
        }
        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            z-index: 110;
            display: none;
        }
        .stats-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 20px;
            z-index: 110;
            display: none;
        }
        @media (max-width: 768px) {
            #toolbar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 100;
            }
            #sidebar {
                top: 0;
                left: -250px;
                height: 100%;
            }
            #sidebar.open {
                transform: translateX(250px);
            }
            #stats-panel {
                top: 0;
                right: -250px;
                height: 100%;
            }
            #stats-panel.open {
                transform: translateX(-250px);
            }
            .menu-toggle, .stats-toggle {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <button class="menu-toggle" id="menu-toggle">‚ò∞</button>
        <button class="stats-toggle" id="stats-toggle">$</button>
        
        <div id="toolbar">
            <button class="tool-btn active" title="Select" id="btn-select">‚úèÔ∏è</button>
            <button class="tool-btn" title="Wall" id="btn-wall">üß±</button>
            <button class="tool-btn" title="Door" id="btn-door">üö™</button>
            <button class="tool-btn" title="Window" id="btn-window">ü™ü</button>
            <button class="tool-btn" title="Scan Room" id="btn-scan">üì∑</button>
            <button class="tool-btn" title="Tile Size" id="btn-tile-size">üìè</button>
            <button class="tool-btn" title="Settings" id="btn-settings">‚öôÔ∏è</button>
        </div>
        
        <div id="sidebar">
            <div id="sidebar-header">Tile Materials</div>
            <div id="sidebar-content">
                <div class="section-title">Floor Tiles</div>
                <div class="material-item">
                    <div class="material-thumb selected" style="background-image: url('https://ik.imagekit.io/pziy0u4kb/tile%201.jpg?updatedAt=1753787882692');" data-texture="floor1"></div>
                    <div class="material-name">Crema Marfil</div>
                </div>
                <div class="material-item">
                    <div class="material-thumb" style="background-image: url('https://ik.imagekit.io/pziy0u4kb/tile%202.png?updatedAt=1753788299488');" data-texture="floor2"></div>
                    <div class="material-name">Slate Grey</div>
                </div>
                <div class="material-item">
                    <div class="material-thumb" style="background-image: url('https://ik.imagekit.io/pziy0u4kb/tile%203.webp?updatedAt=1753788450579');" data-texture="floor3"></div>
                    <div class="material-name">Carrara White</div>
                </div>
                
                <div class="section-title">Wall Tiles</div>
                <div class="material-item">
                    <div class="material-thumb" style="background-image: url('https://ik.imagekit.io/pziy0u4kb/tile%204.webp?updatedAt=1754055287618');" data-texture="wall1"></div>
                    <div class="material-name">Subway White</div>
                </div>
                <div class="material-item">
                    <div class="material-thumb" style="background-image: url('https://ik.imagekit.io/pziy0u4kb/tile%205.jpg?updatedAt=1754055435637');" data-texture="wall2"></div>
                    <div class="material-name">Mediterranean Blue</div>
                </div>
            </div>
        </div>
        
        <div id="viewer-container">
            <div id="viewer"></div>
            
            <div id="mode-switcher">
                <button class="mode-btn active" data-mode="2d">2D</button>
                <button class="mode-btn" data-mode="3d">3D</button>
                <button class="mode-btn" data-mode="fp">FP</button>
            </div>
            
            <div id="first-person-ui">
                WASD to move, SPACE to jump, ESC to exit
            </div>
        </div>
        
        <div id="stats-panel">
            <h3>Project Details</h3>
            <div class="stat-item">
                <div class="stat-label">Floor Area</div>
                <div class="stat-value" id="stat-floor">0 sq.ft</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Wall Area</div>
                <div class="stat-value" id="stat-walls">0 sq.ft</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Tile Count</div>
                <div class="stat-value" id="stat-tile-count">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Tile Cost</div>
                <div class="stat-value" id="stat-cost">$0.00</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Installation Cost</div>
                <div class="stat-value" id="stat-install-cost">$0.00</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Total Cost</div>
                <div class="stat-value" id="stat-total-cost">$0.00</div>
            </div>
        </div>
        
        <div id="room-dimensions">
            <h3>Room Dimensions</h3>
            <div class="dimension-input">
                <label>Width (ft)</label>
                <input type="number" id="room-width" value="12" min="5" max="50">
            </div>
            <div class="dimension-input">
                <label>Depth (ft)</label>
                <input type="number" id="room-depth" value="10" min="5" max="50">
            </div>
            <div class="dimension-input">
                <label>Height (ft)</label>
                <input type="number" id="room-height" value="8" min="5" max="20">
            </div>
            <button id="btn-update-room" style="width: 100%; padding: 8px; background: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">Update Room</button>
        </div>
        
        <div id="tile-size-panel">
            <h3>Tile Size</h3>
            <div class="dimension-input">
                <label>Tile Width (inches)</label>
                <input type="number" id="tile-width" value="12" min="1" step="0.1">
            </div>
            <div class="dimension-input">
                <label>Tile Height (inches)</label>
                <input type="number" id="tile-height" value="12" min="1" step="0.1">
            </div>
            <button id="btn-update-tile-size" style="width: 100%; padding: 8px; background: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px;">Update Tile Size</button>
        </div>
        
        <div id="scan-panel">
            <div id="scan-view"></div>
            <div id="scan-controls">
                <button id="scan-button">Start Scanning</button>
                <button id="cancel-scan">Cancel</button>
            </div>
            <div id="scan-results">
                Move your device slowly around the room to scan
            </div>
        </div>
    </div>
    <script>
        // Main Application
        class TileVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.fpControls = null;
                this.room = null;
                this.floor = null;
                this.walls = [];
                this.currentMode = '3d';
                this.currentTool = 'select';
                this.selectedMaterial = 'floor1';
                this.roomWidth = 12;
                this.roomDepth = 10;
                this.roomHeight = 8;
                this.tilePrice = 3.50;
                this.installationRate = 4.50;
                this.tileWidth = 12; // inches
                this.tileHeight = 12; // inches
                this.isDrawing = false;
                this.startPoint = null;
                this.tempWall = null;
                this.doors = [];
                this.windows = [];
                this.obstacles = [];
                this.isScanning = false;
                this.scannedDimensions = null;
                
                this.init();
                this.setupEventListeners();
                this.createRoom();
                this.checkMobile();
            }
            
            init() {
                // Initialize Three.js
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(15, 15, 15);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('viewer').appendChild(this.renderer.domElement);
                
                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // First-person controls (initially inactive)
                this.fpControls = new THREE.PointerLockControls(this.camera, document.body);
                
                // Lighting
                this.setupLighting();
                
                // Grid helper
                const gridHelper = new THREE.GridHelper(50, 50, 0x888888, 0xcccccc);
                this.scene.add(gridHelper);
                
                // Start animation loop
                this.animate();
            }
            
            checkMobile() {
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (this.isMobile) {
                    document.getElementById('menu-toggle').style.display = 'block';
                    document.getElementById('stats-toggle').style.display = 'block';
                }
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                this.scene.add(directionalLight);
                
                // Hemisphere light for natural illumination
                const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.2);
                hemisphereLight.position.set(0, 20, 0);
                this.scene.add(hemisphereLight);
            }
            
            setupEventListeners() {
                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Tool buttons
                document.getElementById('btn-select').addEventListener('click', () => this.setTool('select'));
                document.getElementById('btn-wall').addEventListener('click', () => this.setTool('wall'));
                document.getElementById('btn-door').addEventListener('click', () => this.setTool('door'));
                document.getElementById('btn-window').addEventListener('click', () => this.setTool('window'));
                document.getElementById('btn-scan').addEventListener('click', () => this.startRoomScan());
                document.getElementById('btn-tile-size').addEventListener('click', () => {
                    document.getElementById('tile-size-panel').style.display = 'block';
                });
                document.getElementById('btn-settings').addEventListener('click', () => this.showSettings());
                
                // Mode switcher
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.setMode(e.target.dataset.mode));
                });
                
                // Material selection
                document.querySelectorAll('.material-thumb').forEach(thumb => {
                    thumb.addEventListener('click', (e) => {
                        document.querySelectorAll('.material-thumb').forEach(t => t.classList.remove('selected'));
                        e.target.classList.add('selected');
                        this.selectedMaterial = e.target.dataset.texture;
                        this.applySelectedMaterial();
                    });
                });
                
                // Room dimensions
                document.getElementById('btn-update-room').addEventListener('click', () => {
                    this.roomWidth = parseFloat(document.getElementById('room-width').value);
                    this.roomDepth = parseFloat(document.getElementById('room-depth').value);
                    this.roomHeight = parseFloat(document.getElementById('room-height').value);
                    this.createRoom();
                    document.getElementById('room-dimensions').style.display = 'none';
                });
                
                // Tile size update
                document.getElementById('btn-update-tile-size').addEventListener('click', () => {
                    this.tileWidth = parseFloat(document.getElementById('tile-width').value);
                    this.tileHeight = parseFloat(document.getElementById('tile-height').value);
                    this.applySelectedMaterial();
                    document.getElementById('tile-size-panel').style.display = 'none';
                });
                
                // First-person controls
                document.addEventListener('keydown', (e) => {
                    if (this.currentMode !== 'fp') return;
                    
                    const moveSpeed = 0.2;
                    const jumpSpeed = 0.5;
                    
                    switch(e.key.toLowerCase()) {
                        case 'w':
                            this.fpControls.moveForward(moveSpeed);
                            break;
                        case 's':
                            this.fpControls.moveForward(-moveSpeed);
                            break;
                        case 'a':
                            this.fpControls.moveRight(-moveSpeed);
                            break;
                        case 'd':
                            this.fpControls.moveRight(moveSpeed);
                            break;
                        case ' ':
                            this.camera.position.y += jumpSpeed;
                            break;
                        case 'escape':
                            this.setMode('3d');
                            break;
                    }
                });
                
                // Mobile menu toggles
                document.getElementById('menu-toggle').addEventListener('click', () => {
                    document.getElementById('sidebar').classList.toggle('open');
                });
                
                document.getElementById('stats-toggle').addEventListener('click', () => {
                    document.getElementById('stats-panel').classList.toggle('open');
                });
                
                // Scan controls
                document.getElementById('scan-button').addEventListener('click', () => this.scanRoom());
                document.getElementById('cancel-scan').addEventListener('click', () => {
                    document.getElementById('scan-panel').style.display = 'none';
                    this.isScanning = false;
                });
                
                // Close panels when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#room-dimensions') && !e.target.closest('#btn-dimensions')) {
                        document.getElementById('room-dimensions').style.display = 'none';
                    }
                    if (!e.target.closest('#tile-size-panel') && !e.target.closest('#btn-tile-size')) {
                        document.getElementById('tile-size-panel').style.display = 'none';
                    }
                });
                
                // Mouse events for drawing
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseup', () => this.onMouseUp());
                
                // Touch events for mobile
                this.renderer.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e));
                this.renderer.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e));
                this.renderer.domElement.addEventListener('touchend', () => this.onTouchEnd());
            }
            
            startRoomScan() {
                if (this.isMobile) {
                    // On mobile, show the scan panel
                    document.getElementById('scan-panel').style.display = 'flex';
                    document.getElementById('scan-results').textContent = 'Move your device slowly around the room to scan';
                } else {
                    // On desktop, simulate a scan
                    this.simulateRoomScan();
                }
            }
            
            scanRoom() {
                this.isScanning = true;
                document.getElementById('scan-button').textContent = 'Scanning...';
                document.getElementById('scan-button').disabled = true;
                
                // In a real app, this would use device motion sensors and camera
                // For demo purposes, we'll simulate a scan after 3 seconds
                setTimeout(() => {
                    this.finishRoomScan();
                }, 3000);
            }
            
            simulateRoomScan() {
                // Simulate scanning a room with random furniture
                const width = 10 + Math.random() * 8; // 10-18 ft
                const depth = 8 + Math.random() * 6; // 8-14 ft
                const height = 8 + Math.random() * 2; // 8-10 ft
                
                this.scannedDimensions = { width, depth, height };
                this.createObstacles();
                
                // Update UI with scanned dimensions
                document.getElementById('room-width').value = width.toFixed(1);
                document.getElementById('room-depth').value = depth.toFixed(1);
                document.getElementById('room-height').value = height.toFixed(1);
                
                // Update the room
                this.roomWidth = width;
                this.roomDepth = depth;
                this.roomHeight = height;
                this.createRoom();
                
                alert(`Room scanned successfully!\nWidth: ${width.toFixed(1)} ft\nDepth: ${depth.toFixed(1)} ft\nHeight: ${height.toFixed(1)} ft`);
            }
            
            finishRoomScan() {
                this.isScanning = false;
                document.getElementById('scan-panel').style.display = 'none';
                document.getElementById('scan-button').textContent = 'Start Scanning';
                document.getElementById('scan-button').disabled = false;
                
                // Simulate getting dimensions from scan
                this.simulateRoomScan();
            }
            
            createObstacles() {
                // Clear existing obstacles
                this.obstacles.forEach(obj => this.scene.remove(obj));
                this.obstacles = [];
                
                // Add some random furniture (for demo purposes)
                const furnitureTypes = ['sofa', 'table', 'cabinet', 'bed', 'wardrobe'];
                const colors = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2B48C, 0xF5DEB3];
                
                for (let i = 0; i < 3; i++) {
                    const type = furnitureTypes[Math.floor(Math.random() * furnitureTypes.length)];
                    const width = 2 + Math.random() * 4;
                    const depth = 1 + Math.random() * 3;
                    const height = 1 + Math.random() * 2;
                    const x = (Math.random() * this.roomWidth) - (this.roomWidth/2);
                    const z = (Math.random() * this.roomDepth) - (this.roomDepth/2);
                    const y = height/2;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    const material = new THREE.MeshBasicMaterial({ color });
                    const furniture = new THREE.Mesh(geometry, material);
                    furniture.position.set(x, y, z);
                    
                    this.scene.add(furniture);
                    this.obstacles.push(furniture);
                }
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('#toolbar .tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`btn-${tool}`).classList.add('active');
                
                // Change cursor based on tool
                const viewer = document.getElementById('viewer');
                viewer.style.cursor = tool === 'select' ? 'default' : 'crosshair';
                
                // If switching from drawing tool, clean up any temp objects
                if (this.tempWall) {
                    this.scene.remove(this.tempWall);
                    this.tempWall = null;
                }
                this.isDrawing = false;
                this.startPoint = null;
            }
            
            showSettings() {
                alert("Settings dialog would appear here.\nIn a full implementation, this would open a settings panel.");
            }
            
            onMouseDown(e) {
                if (this.currentMode !== '2d') return;
                
                // Get mouse position in normalized device coordinates (-1 to +1)
                const mouse = new THREE.Vector2();
                mouse.x = (e.clientX / this.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(e.clientY / this.renderer.domElement.clientHeight) * 2 + 1;
                
                // Convert to world coordinates on the ground plane (y=0)
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                this.startPoint = intersection;
                this.isDrawing = true;
                
                // Handle different tools
                switch(this.currentTool) {
                    case 'wall':
                        this.startWallDrawing(intersection);
                        break;
                    case 'door':
                        this.addDoor(intersection);
                        break;
                    case 'window':
                        this.addWindow(intersection);
                        break;
                }
            }
            
            onTouchStart(e) {
                if (this.currentMode !== '2d') return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const mouse = new THREE.Vector2();
                mouse.x = (touch.clientX / this.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(touch.clientY / this.renderer.domElement.clientHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                
                this.startPoint = intersection;
                this.isDrawing = true;
                
                switch(this.currentTool) {
                    case 'wall':
                        this.startWallDrawing(intersection);
                        break;
                    case 'door':
                        this.addDoor(intersection);
                        break;
                    case 'window':
                        this.addWindow(intersection);
                        break;
                }
            }
            
            onTouchMove(e) {
                if (!this.isDrawing || !this.startPoint || this.currentTool !== 'wall') return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const mouse = new THREE.Vector2();
                mouse.x = (touch.clientX / this.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(touch.clientY / this.renderer.domElement.clientHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const currentPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, currentPoint);
                
                this.updateTempWall(currentPoint);
            }
            
            onTouchEnd() {
                if (!this.isDrawing || !this.tempWall || this.currentTool !== 'wall') return;
                this.finalizeWall();
            }
            
            startWallDrawing(startPoint) {
                this.startPoint = startPoint;
                this.isDrawing = true;
            }
            
            addDoor(position) {
                const doorWidth = 3; // feet
                const doorHeight = 7; // feet
                
                const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.2);
                const doorMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Brown color for door
                
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(position.x, doorHeight/2, position.z);
                this.scene.add(door);
                this.doors.push(door);
            }
            
            addWindow(position) {
                const windowWidth = 4; // feet
                const windowHeight = 4; // feet
                const windowHeightFromFloor = 3; // feet
                
                const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, 0.2);
                const windowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.7
                });
                
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(position.x, windowHeightFromFloor + windowHeight/2, position.z);
                this.scene.add(window);
                this.windows.push(window);
            }
            
            onMouseMove(e) {
                if (!this.isDrawing || !this.startPoint || this.currentTool !== 'wall') return;
                
                // Get current mouse position
                const mouse = new THREE.Vector2();
                mouse.x = (e.clientX / this.renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(e.clientY / this.renderer.domElement.clientHeight) * 2 + 1;
                
                // Convert to world coordinates
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const currentPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, currentPoint);
                
                this.updateTempWall(currentPoint);
            }
            
            updateTempWall(currentPoint) {
                // Remove previous temp wall if exists
                if (this.tempWall) {
                    this.scene.remove(this.tempWall);
                }
                
                // Create a temporary wall visualization
                const wallHeight = this.roomHeight;
                const wallLength = this.startPoint.distanceTo(currentPoint);
                const wallGeometry = new THREE.BoxGeometry(wallLength, wallHeight, 0.2);
                
                // Position the wall between start and current points
                const center = new THREE.Vector3().addVectors(this.startPoint, currentPoint).multiplyScalar(0.5);
                
                // Calculate rotation to face the current point
                const angle = Math.atan2(
                    currentPoint.z - this.startPoint.z,
                    currentPoint.x - this.startPoint.x
                );
                
                this.tempWall = new THREE.Mesh(
                    wallGeometry,
                    new THREE.MeshBasicMaterial({ color: 0x4a6fa5, transparent: true, opacity: 0.7 })
                );
                this.tempWall.position.set(center.x, wallHeight/2, center.z);
                this.tempWall.rotation.y = -angle + Math.PI/2;
                
                this.scene.add(this.tempWall);
            }
            
            onMouseUp() {
                if (!this.isDrawing || !this.tempWall || this.currentTool !== 'wall') return;
                this.finalizeWall();
            }
            finalizeWall() {
// Convert the temporary wall to a permanent wall
const wall = this.tempWall.clone();
wall.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
this.scene.add(wall);
this.walls.push(wall);

// Remove the temporary wall
this.scene.remove(this.tempWall);
this.tempWall = null;

// Reset drawing state
this.isDrawing = false;
this.startPoint = null;

// Update statistics
this.updateStats();
}

setMode(mode) {
this.currentMode = mode;

// Update UI
document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
document.querySelector(`.mode-btn[data-mode="${mode}"]`).classList.add('active');

// Switch between modes
switch(mode) {
case '2d':
this.set2DMode();
break;
case '3d':
this.set3DMode();
break;
case 'fp':
this.setFirstPersonMode();
break;
}
}

set2DMode() {
// Position camera for top-down view
this.camera.position.set(0, 30, 0);
this.camera.lookAt(0, 0, 0);

// Enable orbit controls
this.controls.enabled = true;

// Disable first-person controls
this.fpControls.unlock();
this.scene.remove(this.fpControls.getObject());

// Hide first-person UI
document.getElementById('first-person-ui').style.display = 'none';

// Show room from top
this.controls.update();
}

set3DMode() {
// Position camera for 3D view
this.camera.position.set(15, 15, 15);
this.camera.lookAt(0, 0, 0);

// Enable orbit controls
this.controls.enabled = true;

// Disable first-person controls
this.fpControls.unlock();
this.scene.remove(this.fpControls.getObject());

// Hide first-person UI
document.getElementById('first-person-ui').style.display = 'none';

// Update controls
this.controls.update();
}

setFirstPersonMode() {
// Position camera at human height
this.camera.position.set(0, 5, 0);

// Disable orbit controls
this.controls.enabled = false;

// Enable first-person controls
this.scene.add(this.fpControls.getObject());
this.fpControls.lock();

// Show first-person UI
document.getElementById('first-person-ui').style.display = 'block';
}

createRoom() {
// Clear existing room
if (this.room) {
this.scene.remove(this.room);
}

// Create room group
this.room = new THREE.Group();

// Create floor
const floorGeometry = new THREE.PlaneGeometry(this.roomWidth, this.roomDepth);
const floorMaterial = new THREE.MeshStandardMaterial({
color: 0xffffff,
side: THREE.DoubleSide
});
this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
this.floor.rotation.x = Math.PI / 2; // Rotate to be horizontal
this.floor.position.y = 0;
this.room.add(this.floor);

// Create walls
this.createWalls();

// Add room to scene
this.scene.add(this.room);

// Apply selected material
this.applySelectedMaterial();

// Update statistics
this.updateStats();
}

createWalls() {
// Clear existing walls
this.walls.forEach(wall => this.scene.remove(wall));
this.walls = [];

const wallHeight = this.roomHeight;
const wallThickness = 0.2;

// Wall materials
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xe0e0e0 });

// Back wall
const backWallGeometry = new THREE.BoxGeometry(this.roomWidth, wallHeight, wallThickness);
const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
backWall.position.set(0, wallHeight/2, -this.roomDepth/2);
this.walls.push(backWall);
this.room.add(backWall);

// Front wall
const frontWallGeometry = new THREE.BoxGeometry(this.roomWidth, wallHeight, wallThickness);
const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
frontWall.position.set(0, wallHeight/2, this.roomDepth/2);
this.walls.push(frontWall);
this.room.add(frontWall);

// Left wall
const leftWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, this.roomDepth);
const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
leftWall.position.set(-this.roomWidth/2, wallHeight/2, 0);
this.walls.push(leftWall);
this.room.add(leftWall);

// Right wall
const rightWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, this.roomDepth);
const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
rightWall.position.set(this.roomWidth/2, wallHeight/2, 0);
this.walls.push(rightWall);
this.room.add(rightWall);
}

applySelectedMaterial() {
// Determine if this is a floor or wall material
const isFloorMaterial = this.selectedMaterial.startsWith('floor');

if (isFloorMaterial && this.floor) {
// Apply texture to floor
const textureLoader = new THREE.TextureLoader();

// Calculate how many tiles we need
const tileWidthFt = this.tileWidth / 12; // Convert inches to feet
const tileHeightFt = this.tileHeight / 12; // Convert inches to feet

// Load texture based on selection
let textureUrl = '';
switch(this.selectedMaterial) {
case 'floor1':
textureUrl = 'https://ik.imagekit.io/pziy0u4kb/tile%201.jpg?updatedAt=1753787882692';
break;
case 'floor2':
textureUrl = 'https://ik.imagekit.io/pziy0u4kb/tile%202.png?updatedAt=1753788299488';
break;
case 'floor3':
textureUrl = 'https://ik.imagekit.io/pziy0u4kb/tile%203.webp?updatedAt=1753788450579';
break;
}

textureLoader.load(textureUrl, (texture) => {
// Set texture wrapping and repeat
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(
this.roomWidth / tileWidthFt,
this.roomDepth / tileHeightFt
);

// Apply texture to floor
this.floor.material.map = texture;
this.floor.material.needsUpdate = true;
});
} else if (!isFloorMaterial) {
// Apply texture to walls
const textureLoader = new THREE.TextureLoader();

// Calculate how many tiles we need
const tileWidthFt = this.tileWidth / 12; // Convert inches to feet
const tileHeightFt = this.tileHeight / 12; // Convert inches to feet

// Load texture based on selection
let textureUrl = '';
switch(this.selectedMaterial) {
case 'wall1':
textureUrl = 'https://ik.imagekit.io/pziy0u4kb/tile%204.webp?updatedAt=1754055287618';
break;
case 'wall2':
textureUrl = 'https://ik.imagekit.io/pziy0u4kb/tile%205.jpg?updatedAt=1754055435637';
break;
}

textureLoader.load(textureUrl, (texture) => {
// Set texture wrapping and repeat
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;

// Apply texture to each wall
this.walls.forEach((wall, index) => {
// Different walls have different dimensions
let repeatX, repeatY;

if (index < 2) { // Front and back walls
repeatX = this.roomWidth / tileWidthFt;
repeatY = this.roomHeight / tileHeightFt;
} else { // Left and right walls
repeatX = this.roomDepth / tileWidthFt;
repeatY = this.roomHeight / tileHeightFt;
}

// Clone texture for each wall to have different repeat values
const wallTexture = texture.clone();
wallTexture.wrapS = THREE.RepeatWrapping;
wallTexture.wrapT = THREE.RepeatWrapping;
wallTexture.repeat.set(repeatX, repeatY);

wall.material.map = wallTexture;
wall.material.needsUpdate = true;
});
});
}

// Update statistics
this.updateStats();
}

updateStats() {
// Calculate floor area
const floorArea = this.roomWidth * this.roomDepth;

// Calculate wall area (minus doors and windows)
let wallArea = 2 * (this.roomWidth + this.roomDepth) * this.roomHeight;

// Subtract door areas
this.doors.forEach(door => {
const doorWidth = door.geometry.parameters.width;
const doorHeight = door.geometry.parameters.height;
wallArea -= doorWidth * doorHeight;
});

// Subtract window areas
this.windows.forEach(window => {
const windowWidth = window.geometry.parameters.width;
const windowHeight = window.geometry.parameters.height;
wallArea -= windowWidth * windowHeight;
});

// Calculate tile count
const tileWidthFt = this.tileWidth / 12; // Convert inches to feet
const tileHeightFt = this.tileHeight / 12; // Convert inches to feet
const tileArea = tileWidthFt * tileHeightFt;

// Determine if we're calculating for floor or walls
const isFloorMaterial = this.selectedMaterial.startsWith('floor');
const areaToCover = isFloorMaterial ? floorArea : wallArea;

// Add 10% for waste
const tileCount = Math.ceil(areaToCover / tileArea * 1.1);

// Calculate costs
const tileCost = tileCount * this.tilePrice;
const installCost = areaToCover * this.installationRate;
const totalCost = tileCost + installCost;

// Update UI
document.getElementById('stat-floor').textContent = `${floorArea.toFixed(1)} sq.ft`;
document.getElementById('stat-walls').textContent = `${wallArea.toFixed(1)} sq.ft`;
document.getElementById('stat-tile-count').textContent = tileCount.toString();
document.getElementById('stat-cost').textContent = `$${tileCost.toFixed(2)}`;
document.getElementById('stat-install-cost').textContent = `$${installCost.toFixed(2)}`;
document.getElementById('stat-total-cost').textContent = `$${totalCost.toFixed(2)}`;
}

onWindowResize() {
this.camera.aspect = window.innerWidth / window.innerHeight;
this.camera.updateProjectionMatrix();
this.renderer.setSize(window.innerWidth, window.innerHeight);
}

animate() {
requestAnimationFrame(() => this.animate());

if (this.controls && this.controls.enabled) {
this.controls.update();
}

this.renderer.render(this.scene, this.camera);
}
}

// Initialize the application when the page loads
window.addEventListener('DOMContentLoaded', () => {
const app = new TileVisualizer();
});
</script></body>
</html>

            
